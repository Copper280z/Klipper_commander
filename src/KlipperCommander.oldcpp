#include "KlipperCommander.h"

#ifdef USE_TINYUSB
    KlipperCommander::KlipperCommander(Adafruit_USBD_CDC &Serial) : serial(Serial) {
        serial = Serial;
    }
#else
    KlipperCommander::KlipperCommander(arduino::HardwareSerial &Serial) : serial(Serial) {
        serial = Serial;
    }
#endif

void KlipperCommander::recieve_serial() {
    uint8_t bytes_read = serial.read(buf, 64);

    // <1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>

    //possible entry states
    // - expect the first byte read to be the first byte of a new message
    // - expect the first byte read to be somewhere in the middle of a message

    // if we're starting to read at the beginning of a new message
    // Serial.println("");
    // Serial.println("Recieve Serial");

    if (bytes_read == 0) return;

    if (input_buffer_offset == 0) {
        // Serial.println("Starting` Fresh Msg");
        msg_length = buf[0];

        // if the message is longer than the number of bytes we read
        if (msg_length > bytes_read) {
            input_buffer_offset = bytes_read;
            memcpy(commands[command_idx],buf, bytes_read);
        } else {    
            // if the message is shorter than the number of bytes we read
            memcpy(commands[command_idx], buf, msg_length);
            
            if (commands[command_idx][msg_length-1] != SYNC_BYTE || msg_length >= MAX_MESSAGE_LEN || msg_length <= MIN_MESSAGE_LEN){
                input_buffer_offset = 0;
                return;
            }

            //advance the command index
            if (command_idx+1 < COMMAND_QUEUE_LEN){
                command_idx += 1;
            } else {
                command_idx = 0;
            }
            input_buffer_offset = bytes_read-msg_length;
            if (input_buffer_offset > 0) {
                memcpy(commands[command_idx], &buf[msg_length], input_buffer_offset);
                msg_length = buf[input_buffer_offset + 1];
            }
        } 
    } else if (bytes_read == 0){
        // Serial.println("No Data");
    } else {
        
        // nonzero offset, starting in the middle of a message
        // assume message length was set previously and is currently correct
        if (bytes_read > (msg_length-input_buffer_offset)) {
            // Serial.println("Starting in Middle of Msg");
            // we read more bytes than required to finish the previouos message
            memcpy(&commands[command_idx][input_buffer_offset], buf, msg_length-input_buffer_offset);
            
            if (commands[command_idx][msg_length-1] != SYNC_BYTE || msg_length >= MAX_MESSAGE_LEN || msg_length <= MIN_MESSAGE_LEN){
                input_buffer_offset = 0;
                return;
            }

            //advance the command index
            if (command_idx+1 < COMMAND_QUEUE_LEN){
                command_idx += 1;
            } else {
                command_idx = 0;
            }
        
            input_buffer_offset = bytes_read-msg_length;
            if (input_buffer_offset > 0) {
                memcpy(commands[command_idx], &buf[msg_length], input_buffer_offset);
                msg_length = buf[input_buffer_offset + 1];
            }
        } else {
            // we didn't read enough bytes to complete the message
            memcpy(&commands[command_idx][input_buffer_offset], buf, bytes_read);
            input_buffer_offset += bytes_read;
        }
    }

//read the first byte and save as length
//whenever a byte is available read it into the buffer until length bytes have been read
//check that this is a valid message
// - check that there's a sync byte at the end of the array
// - check crc`
}

void KlipperCommander::parse_message() {
    // only try to parse up to command_idx-1, command_idx may be incomplete
    uint8_t commands_to_parse = command_idx - command_parsed_idx;

    if (commands_to_parse > 0) {
        Serial.printf("%d commands in queue\n", commands_to_parse);
        Serial.printf("%d parsed_idx\n", command_parsed_idx);
        Serial.printf("%d write idx\n", command_idx);
        uint8_t cmd_len = commands[command_parsed_idx][0];
        Serial.printf("Length of command being parsed: %d\n", cmd_len);

        for (int i=0; i<cmd_len;i++){
            Serial.print(commands[command_parsed_idx][i], HEX);
            Serial.print(" ");
        }
        Serial.print("\n");

        if (cmd_len < 64 && cmd_len != 0 ) {
            sync = commands[command_parsed_idx][cmd_len-1];

            uint16_t calc_crc = crc16(commands[command_parsed_idx], cmd_len-3);
            uint16_t msg_crc = parse_crc(commands[command_parsed_idx], cmd_len);
            sequence = commands[command_parsed_idx][1];

            if (sync == SYNC_BYTE && calc_crc == msg_crc) {
                Serial.println("valid");
                // Serial.printf("calc'd crc: 0x%x\n", calc_crc);
                // Serial.printf("msg crc:    0x%x\n", msg_crc);
                // Serial.printf("sequence high bytes: 0x%x\n", sequence & 0b11110000 ); // sequence >> 3 does same thing
                ACK();
                Serial.printf("sequence low bytes: %u\n", sequence & 0b00001111 );
                VarInt cmd_id_var = parse_vlq_int(&commands[command_parsed_idx][2], cmd_len-MIN_MESSAGE_LEN);
                Serial.printf("Command ID:  %u\n", (int32_t) cmd_id_var.value);
                command_dispatcher(cmd_id_var.value, &commands[command_parsed_idx][2], cmd_len-MIN_MESSAGE_LEN);

            }else {
                Serial.printf("len %d - sync %d not valid\n", cmd_len, sync);
                Serial.printf("calc'd crc: 0x%x\n", calc_crc);
                Serial.printf("msg crc: 0x%x\n", msg_crc);
                NACK();
            }
        }
        if (command_parsed_idx+1 < COMMAND_QUEUE_LEN){
            command_parsed_idx += 1;
        } else {
            command_parsed_idx = 0;
        }
    }
}

void KlipperCommander::command_dispatcher(uint32_t cmd_id, uint8_t *msg, uint8_t length) {
    switch (cmd_id) {
        case 1:
            VarInt offset_var = parse_vlq_int((msg+1), length-1);
            VarInt amount_var = parse_vlq_int((msg+1+offset_var.length), length-1-offset_var.length);
            Serial.printf("Offset: %u - len: %u\n", (int32_t) offset_var.value, offset_var.length);
            Serial.printf("Amount: %u - len: %u\n", amount_var.value, amount_var.length);
            send_config(offset_var.value, amount_var.value);
    }
}

void KlipperCommander::send_serial(){
    for (uint8_t i=out_buf_send_idx; i<out_buf_write_idx; i++){
        Serial.printf("msg sent: ");
        print_byte_array(output_buffer[i], output_buffer[i][0]);
        serial.write(output_buffer[i], output_buffer[i][0]);
        out_buf_send_idx+=1;
    }

}

void KlipperCommander::ACK() {
    uint8_t new_sequence = ((sequence +1 ) & 0b00001111) | 0x10;
    // Serial.printf("ACK sequence high bytes: 0x%x\n", new_sequence & 0b11110000 );
    // Serial.printf("ACK sequence low bytes: %u\n", new_sequence & 0b00001111 );

    output_buffer[out_buf_write_idx][0] = 5;
    output_buffer[out_buf_write_idx][1] = new_sequence;
    uint16_t crc = crc16(output_buffer[out_buf_write_idx],2);
    output_buffer[out_buf_write_idx][2] = (uint8_t) (crc >> 8);
    output_buffer[out_buf_write_idx][3] = (uint8_t) (crc & 0xFF);
    output_buffer[out_buf_write_idx][4] = SYNC_BYTE;
    
    if (out_buf_write_idx+1 < SEND_QUEUE_LEN){
        out_buf_write_idx += 1;
    } else {
        out_buf_write_idx = 0;
    }


}

void KlipperCommander::NACK() {
    uint8_t new_sequence = ((sequence -1 ) & 0b00001111) | 0x10;

    output_buffer[out_buf_write_idx][0] = 5;
    output_buffer[out_buf_write_idx][1] = new_sequence;
    uint16_t crc = crc16(output_buffer[out_buf_write_idx],2);
    output_buffer[out_buf_write_idx][2] = (uint8_t) (crc >> 8);
    output_buffer[out_buf_write_idx][3] = (uint8_t) (crc & 0xFF);
    output_buffer[out_buf_write_idx][4] = SYNC_BYTE;

    if (out_buf_write_idx+1 < SEND_QUEUE_LEN){
        out_buf_write_idx += 1;
    } else {
        out_buf_write_idx = 0;
    }
}

uint16_t KlipperCommander::crc16(uint8_t* arr, uint8_t length) {
    uint16_t crc = 0xFFFF;
    for (int i = 0; i < length; i++) {
        uint8_t b = *(arr+i) ^ (crc & 0xFF);
        b = b ^ (b << 4);
        crc = ((uint16_t)b << 8 | crc >> 8) ^ ((uint16_t)b >> 4) ^ ((uint16_t)b << 3);
    }
    return crc;
}

VarInt KlipperCommander::parse_vlq_int(uint8_t* bytes, uint8_t length) {
    uint32_t c = *(bytes);
    uint32_t v = 0; //c & 0x7F;

    //if vlq is negative(?)
    if ((c & 0x60) == 0x60) {
        v |= (uint32_t) ((int32_t) -0x20);
    }
    uint8_t j=0;
    for (int i=0; i<length; i++) {
        c = *(bytes+i);
        v = (v << 7) | (c & 0x7F);
        j+=1;

        if ((c & 0x80) != 0x80){
            break;
        }

    }
    VarInt var = VarInt{v,j};
    return var;
}

uint16_t KlipperCommander::parse_crc(uint8_t* msg, uint8_t length) {
    uint16_t crc = (uint16_t) *(msg+length-3) << 8 | (uint16_t) *(msg+length-2);
    return crc;
}

void KlipperCommander::send_config(uint32_t offset, uint32_t amount) {

    if ((offset+amount) < CONFIG_DICT_LENGTH) {
        enqueue_config_response(offset, &config[offset], amount);
    } else if(offset==CONFIG_DICT_LENGTH){
        // uint8_t msg[] = {0,CONFIG_DICT_LENGTH,0};
        enqueue_config_response(offset, &config[offset], CONFIG_DICT_LENGTH-offset);

    } else {
        enqueue_config_response(offset, &config[offset], CONFIG_DICT_LENGTH-offset);
    }
}

void KlipperCommander::enqueue_response(uint8_t* msg, uint8_t length) {
    uint8_t send_cmd_len = 5+length;

    uint8_t new_sequence = ((sequence + 1 ) & 0b00001111) | 0x10;

    output_buffer[out_buf_write_idx][0] = send_cmd_len;
    output_buffer[out_buf_write_idx][1] = new_sequence;
    for (int i=0;i<length;i++) {
        output_buffer[out_buf_write_idx][i+2] = *(msg+i);
    }
    uint16_t crc = crc16(output_buffer[out_buf_write_idx],send_cmd_len-3);
    output_buffer[out_buf_write_idx][2+length] = (uint8_t) (crc >> 8);
    output_buffer[out_buf_write_idx][3+length] = (uint8_t) (crc & 0xFF);
    output_buffer[out_buf_write_idx][4+length] = SYNC_BYTE;

    if (out_buf_write_idx+1 < SEND_QUEUE_LEN){
        out_buf_write_idx += 1;
    } else {
        out_buf_write_idx = 0;
    }
}

void KlipperCommander::enqueue_config_response(uint32_t offset, uint8_t* msg, uint8_t count) {
    uint8_t new_sequence = ((sequence +1 ) & 0b00001111) | 0x10;
    uint8_t offset_bytes = encode_vlq_int(&output_buffer[out_buf_write_idx][3], offset);
    uint8_t count_bytes = encode_vlq_int(&output_buffer[out_buf_write_idx][3+offset_bytes], count);
    uint8_t vlq_bytes = offset_bytes+count_bytes;
    uint8_t send_cmd_len = 6+count+vlq_bytes;

    output_buffer[out_buf_write_idx][0] = send_cmd_len;
    output_buffer[out_buf_write_idx][1] = new_sequence;
    output_buffer[out_buf_write_idx][2] = 0; // command id - "identify_response"
    
    for (int i=0;i<count;i++) {
        output_buffer[out_buf_write_idx][i+3+vlq_bytes] = *(msg+i);
    }

    uint16_t crc = crc16(output_buffer[out_buf_write_idx],send_cmd_len-3);
    output_buffer[out_buf_write_idx][3+vlq_bytes+count] = (uint8_t) (crc >> 8);
    output_buffer[out_buf_write_idx][4+vlq_bytes+count] = (uint8_t) (crc & 0xFF);
    output_buffer[out_buf_write_idx][5+vlq_bytes+count] = SYNC_BYTE;

    Serial.printf("command length: %u - 0x%x\n", send_cmd_len,send_cmd_len);
    Serial.printf("Parsed crc: 0x%x\n", parse_crc(output_buffer[out_buf_write_idx],send_cmd_len));
    Serial.printf("Calc'd crc: 0x%x\n", crc);

    if (out_buf_write_idx+1 < SEND_QUEUE_LEN){
        out_buf_write_idx += 1;
    } else {
        out_buf_write_idx = 0;
    }
}

void print_byte_array(uint8_t* arr, uint8_t len){
    for (int i=0; i<len;i++){
        Serial.print(*(arr+i), HEX);
        Serial.print(" ");
    }
    Serial.print("\n");
}

// copy+paste from klipper, rewrite without goto
uint8_t KlipperCommander::encode_vlq_int(uint8_t *p, uint32_t v) {
    int32_t sv = v;
    uint8_t bytes=0;
    if (sv < (3L<<5)  && sv >= -(1L<<5))  goto f4;
    if (sv < (3L<<12) && sv >= -(1L<<12)) goto f3;
    if (sv < (3L<<19) && sv >= -(1L<<19)) goto f2;
    if (sv < (3L<<26) && sv >= -(1L<<26)) goto f1;
    *p++ = (v>>28) | 0x80;
    bytes+=1;
f1: *p++ = ((v>>21) & 0x7f) | 0x80;
    bytes+=1;
f2: *p++ = ((v>>14) & 0x7f) | 0x80;
    bytes+=1;
f3: *p++ = ((v>>7) & 0x7f) | 0x80;
    bytes+=1;
f4: *p++ = v & 0x7f;
    bytes+=1;
    return bytes;
}